# GDI
GDI (Graphics Device Interface) это универсальный компонент Windоws, который позволяет выводить графику на различных графических устройствах.  
В GDI отсутствует возможность вывода сглаженных векторных примитивов. 
По сравнению с современными библиотеками GDI имеет низкую производительность, так как отсутствует аппаратное ускорение.

## Ссылки 
[Компонент Windows GDI](https://learn.microsoft.com/ru-ru/windows/win32/gdi/windows-gdi)  
[Лекция GDI и GDI+](https://www.youtube.com/watch?v=VrneWOhqGVQ)  

## Обработка сообщений WM_PAINT
Если в контексте графического устройства установили выбранным собственный шрифт, то пока в контексте не установим исходный системный шрифт, удалить графический объект будет невозможно.  
Число графических объектов в исполняющемся процессе ограничено (примерно 10000 объектов).
```c++
#define ARRAY_SIZE(a) sizeof(a)/sizeof(*a)

LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {

  // Сообщения от ОС
  switch (uMsg) {

    // Выполняется закрытие окна.
    case WM_DESTROY:
      PostQuitMessage(0);
      return 0;

    // Необходимо обновить фон окна.
    case WM_ERASEBKGND:
      return 1; // Сообщили ОС, что мы обновили фон окна.

    // Необходимо обновить часть окна приложения.
    case WM_PAINT:
      PAINTSTRUCT ps;
      HDC dc = BeginPaint(hWnd, &ps);
      OnPaint(dc);
      EndPaint(hWnd, &ps);
      return 0;
  }
  return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

void OnPaint(HDC hdc) {

  // В контексте устройства устанавливаем выбранным новый шрифт и получаем предыдущий шрифт.
  HGDIOBJ oldFont = SelectObject(hdc, newFont);

  // Выводим текст заданным цветом и выбранным шрифтом.
  SetTextColor(hdc, RGB(51, 120, 27));
  TCHAR text[] = "привет";
  //TextOut(hdc, 0, 0, text, strlen(text));
  //TextOut(hdc, 0, 0, text, sizeof(text)/sizeof(*text));
  TextOut(hdc, 0, 0, text, ARRAY_SIZE(text));  

  // Восстанавливаем в контексте исходный шрифт, наш шрифт освобождается.
  SelectObject(hdc, oldFont);

  // Удаляем графический объект шрифт.
  DeleteObject(hFont1);

}
```
Использование двойной буферизации (или теневого буфера кардра) исключает мерцание при анимации (быстрой смене кадров) сцены. Но и в этом случае мерцание может возникать.
Мерцание появляется, так как перед сообщением WM_PAINT "Рисование содержимого поверх фона" окну может быть передано сообщение WM_ERASEBKGND "Очистка фона окна", обработчик по умолчанию которого стирает изображение с поверхности окна.  
Для исключения мерцания, необходимо перехватить сообщение WM_ERASEBKGND и не выполнять обработку по умолчанию и сообщив ОС, что ничего стирать не нужно.
